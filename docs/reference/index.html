<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · AuditoryNerveFiber.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AuditoryNerveFiber.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Wrappers"><span>Wrappers</span></a></li><li><a class="tocitem" href="#Bindings"><span>Bindings</span></a></li></ul></li><li><a class="tocitem" href="../validation/">-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/guestdaniel/ANF.jl/blob/master/src_docs/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>Here, you can see the documentation for each type and method provided by AuditoryNerveFiber.jl. Higher-level functions designed for end users are documented first, while lower-level functions designed mostly for internal are documented later.</p><h2 id="Wrappers"><a class="docs-heading-anchor" href="#Wrappers">Wrappers</a><a id="Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrappers" title="Permalink"></a></h2><p>Wrappers are functions that &quot;wrap&quot; around lower-level bindings and/or implementations and provide more convenience than the bindings themselves. For example, when calling wrappers a user should never have to worry about handling pointers, pre-allocating arrays, etc. These are the functions that most users will want to use in their own code. Presently, the wrappers provide access to the Zilany, Bruce, and Carney (2014) auditory-nerve model and all share the same basic signature:</p><pre><code class="language-julia hljs">function_name(input, cf; kwargs...)</code></pre><p>where the input is a 1D array, cf is a characteristic frequency in Hz, and kwargs are various other parameters that have default values (i.e., you can set them if you want to, but if you don&#39;t a default value will be used). Below, you can see each of the wrappers documented below, but you can also head over to <a href="../examples/#Examples">Examples</a> to see examples of how these functions can be used.</p><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.sim_ihc_zbc2014" href="#AuditoryNerveFiber.sim_ihc_zbc2014"><code>AuditoryNerveFiber.sim_ihc_zbc2014</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_ihc_zbc2014(input, cf; fs=10e4, cohc=1.0, cihc=1.0, species=&quot;human&quot;, n_rep=1)</code></pre><p>Simulates inner hair cell potential for given acoustic input.</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{Float64}</code>: sound pressure waveform in pascals</li><li><code>cf::Float64</code>: characteristic frequency of the IHC in Hz</li><li><code>fs::Float64</code>: sampling rate in Hz</li><li><code>cohc::Float64</code>: outer hair cell survival (from 0 to 1)</li><li><code>cihc::Float64</code>: inner hair cell survival (from 0 to 1)</li><li><code>species::String</code>: species, either (&quot;cat&quot; = cat, &quot;human&quot; = humans with Shera tuning, &quot;human_glasberg&quot; = humans with Glasberg tuning)</li><li><code>n_rep::Int64</code>: how many repetitions to perform. Because the inner hair cell stage has no randomness, <code>n_rep</code> &gt; 1 simply concatenates <code>n_rep</code> copies of IHC simulation and returns </li></ul><p><strong>Returns</strong></p><ul><li><code>output::Vector{Float64}</code>: inner hair cell potential output, size of <code>length(input)*n_rep</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L267-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.sim_synapse_zbc2014" href="#AuditoryNerveFiber.sim_synapse_zbc2014"><code>AuditoryNerveFiber.sim_synapse_zbc2014</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_synapse_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, fiber_type=&quot;high&quot;, power_law=&quot;approximate&quot;, fractional=false, n_rep=1)</code></pre><p>Simulates synapse output for a given inner hair cell input</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{Float64}</code>: input hair cell potential (from sim<em>ihc</em>zbc2014)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>fs::Float64</code>: sampling rate of the <em>input</em> in Hz</li><li><code>fs_synapse::Float64</code>: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.</li><li><code>fiber_type::String</code>: fiber type, one of (&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) spontaneous rate</li><li><code>power_law::String</code>: whether we use true or approximate power law adaptation, one of (&quot;actual&quot;, &quot;approximate&quot;)</li><li><code>fractional::Bool</code>: whether we use ffGn or not, one of (true, false)</li><li><code>n_rep::Int64</code>: number of repetititons to run. We assume that the input was also generated using <code>n_rep=n_rep</code>, hence we infer that the input acoustic waveform is of length <code>length(input)/n_rep</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>output::Vector{Float64}</code>: synapse output (unknown units?), length is <code>length(input)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L310-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.sim_an_zbc2014" href="#AuditoryNerveFiber.sim_an_zbc2014"><code>AuditoryNerveFiber.sim_an_zbc2014</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_an_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, power_law=&quot;approximate&quot;, fractional=false, n_rep=1)</code></pre><p>Simulates auditory nerve output (spikes and firing rate) for a given inner hair cell input</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{Float64}</code>: input hair cell potential (from sim<em>ihc</em>zbc2014)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>fs::Float64</code>: sampling rate of the <em>input</em> in Hz</li><li><code>fs_synapse::Float64</code>: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.</li><li><code>fiber_type::String</code>: fiber type, one of (&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) spontaneous rate</li><li><code>power_law::String</code>: whether we use true or approximate power law adaptation, one of (&quot;actual&quot;, &quot;approximate&quot;)</li><li><code>fractional::Bool</code>: whether we use ffGn or not, one of (true, talse)</li><li><code>n_rep::Int64</code>: number of repetititons to run. We assume that the input was also generated using <code>n_rep=n_rep</code>, hence we infer that the input acoustic waveform is of length <code>length(input)/n_rep</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>meanrate::Vector{Float64}</code>: analytical estimate of instantaneous firing rate, of size <code>length(input)/n_rep</code></li><li><code>varrrate::Vector{Float64}</code>: analytical estimate of instantaneous firing rate variance, of size <code>length(input)/n_rep</code></li><li><code>psth::Vector{Float64}</code>: peri-stimulus time histogram, of size <code>length(input)/n_rep</code></li></ul><p><strong>Notes</strong></p><ul><li>The behavior of <code>n_rep</code> in <code>sim_an_zbc2014</code> and derived functions differs slightly from </li></ul><p><code>sim_synapse_zbc2014</code>. <code>sim_synapse_zbc2014</code> will return an array of length  <code>length(input)</code>, and will contain a single response to <code>n_rep</code> concatenated copies  of the inner hair cell potential to a single copy of the underlying acoustic stimulus  (assuming that <code>sim_ihc_zbc2014</code> was also evaluated using <code>n_rep=n_rep</code>). <code>sim_an_zbc2014</code> will return an array of length <code>length(input)</code>. Underneath, it generates the same synapse response as <code>sim_synapse_zbc2014</code>, but then averages over the repetitions and averages the spike train into a peristimulus time histogram (PSTH).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L359-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.sim_anrate_zbc2014" href="#AuditoryNerveFiber.sim_anrate_zbc2014"><code>AuditoryNerveFiber.sim_anrate_zbc2014</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_anrate_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, power_law=&quot;approximate&quot;, fractional=false)</code></pre><p>Simulates auditory nerve output (instantaneous firing rate) for a given inner hair cell input</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{Float64}</code>: input hair cell potential (from sim<em>ihc</em>zbc2014)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>fs::Float64</code>: sampling rate of the <em>input</em> in Hz</li><li><code>fs_synapse::Float64</code>: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.</li><li><code>fiber_type::String</code>: fiber type, one of (&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) spontaneous rate</li><li><code>power_law::String</code>: whether we use true or approximate power law adaptation, one of (&quot;actual&quot;, &quot;approximate&quot;)</li><li><code>fractional::Bool</code>: whether we use ffGn or not, one of (true, talse)</li><li><code>n_rep::Int64</code>: number of repetititons to run </li></ul><p><strong>Returns</strong></p><ul><li><code>psth::Vector{Float64}</code>: analytical estimate of instantaneous firing rate, size of <code>length(input)</code> (see docs for <code>sim_an_zbc2014</code> to understand why)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L454-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.sim_spikes_zbc2014" href="#AuditoryNerveFiber.sim_spikes_zbc2014"><code>AuditoryNerveFiber.sim_spikes_zbc2014</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_spikes_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, power_law=&quot;approximate&quot;, fractional=false, n_rep=1)</code></pre><p>Simulates auditory nerve output (spikes only) for a given inner hair cell input</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{Float64}</code>: input hair cell potential (from sim<em>ihc</em>zbc2014)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>fs::Float64</code>: sampling rate of the <em>input</em> in Hz</li><li><code>fs_synapse::Float64</code>: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.</li><li><code>fiber_type::String</code>: fiber type, one of (&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) spontaneous rate</li><li><code>power_law::String</code>: whether we use true or approximate power law adaptation, one of (&quot;actual&quot;, &quot;approximate&quot;)</li><li><code>fractional::Bool</code>: whether we use ffGn or not, one of (true, talse)</li><li><code>n_rep::Int64</code>: number of repetititons to run </li></ul><p><strong>Returns</strong></p><ul><li><code>psth::Vector{Float64}</code>: peri-stimulus time histogram, size of <code>length(input)/n_rep</code> (see docs for <code>sim_an_zbc2014</code> to understand why)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L417-L434">source</a></section></article><h2 id="Bindings"><a class="docs-heading-anchor" href="#Bindings">Bindings</a><a id="Bindings-1"></a><a class="docs-heading-anchor-permalink" href="#Bindings" title="Permalink"></a></h2><p>Bindings are functions that directly interface with external implementations of models in other languages.  All bindings here work generally the same way:</p><ul><li>Inputs are passed directly to external functions with minimal or no input checking or preprocessing</li><li>No defaults are provided</li><li>Names and types of variables match those of the original-language source code</li></ul><p>Generally, it is expected that end-users will never need to call these functions.  Instead, they should use a wrapper or another higher-level function to access the same functionality in a a more &quot;user-friendly&quot; way.</p><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.BM!" href="#AuditoryNerveFiber.BM!"><code>AuditoryNerveFiber.BM!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BM!(px, cf, nrep, tdres, totalstim, cohc, cihc, species, ihcout, bmout)</code></pre><p>Direct binding to BM C function in model_IHC.c</p><p>Passes arguments directly to BM using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.</p><p><strong>Arguments</strong></p><ul><li><code>px::Vector{Float64}</code>: sound pressure waveform in pascals</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>nrep::Int32</code>: number of repetitions to simulate. Note that for the IHC simulation, one &quot;true&quot; simulation is conducted and then that simulation is copied and tiled (because there is no randomness in the IHC simulation) to simulate multiple times.</li><li><code>tdres::Float64</code>: time-domain resolution (i.e., reciprocal of sampling rate)</li><li><code>totalstim::Int32</code>: number of samples in simulation</li><li><code>cohc::Float64</code>: outer hair cell survival (from 0 to 1)</li><li><code>cihc::Float64</code>: inner hair cell survival (from 0 to 1)</li><li><code>species::Int32</code>: species, either (1 = cat, 2 = humans with Shera tuning, 3 = humans with Glasberg tuning)</li><li><code>ihcout::Vector{Float64}</code>: array of same size as <code>px</code>, used to store IHC output from C</li><li><code>bmout::Vector{Float64}</code>: array of same size as <code>px</code>, used to store BM output from C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L491-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.IHCAN!" href="#AuditoryNerveFiber.IHCAN!"><code>AuditoryNerveFiber.IHCAN!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IHCAN!(px, cf, nrep, tdres, totalstim, cohc, cihc, species, ihcout)</code></pre><p>Direct binding to IHCAN C function in model_IHC.c</p><p>Passes arguments directly to IHCAN using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.</p><p><strong>Arguments</strong></p><ul><li><code>px::Vector{Float64}</code>: sound pressure waveform in pascals</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>nrep::Int32</code>: number of repetitions to simulate. Note that for the IHC simulation, one &quot;true&quot; simulation is conducted and then that simulation is copied and tiled (because there is no randomness in the IHC simulation) to simulate multiple times.</li><li><code>tdres::Float64</code>: time-domain resolution (i.e., reciprocal of sampling rate)</li><li><code>totalstim::Int32</code>: number of samples in simulation</li><li><code>cohc::Float64</code>: outer hair cell survival (from 0 to 1)</li><li><code>cihc::Float64</code>: inner hair cell survival (from 0 to 1)</li><li><code>species::Int32</code>: species, either (1 = cat, 2 = humans with Shera tuning, 3 = humans with Glasberg tuning)</li><li><code>ihcout::Vector{Float64}</code>: array of same size as <code>px</code>, used to store output from C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L546-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.Synapse!" href="#AuditoryNerveFiber.Synapse!"><code>AuditoryNerveFiber.Synapse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Synapse!(ihcout, tdres, cf, totalstim, nrep, spont, noiseType, implnt, sampFreq, synouttmp)</code></pre><p>Direct binding to Synapse C function in model_Synapse.c</p><p>Passes arguments directly to Synapse using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.</p><p><strong>Arguments</strong></p><ul><li><code>ihcout::Vector{Float64}</code>: output from IHC simulation (<code>IHCAN!</code>)</li><li><code>tdres::Float64</code>: time-domain resolution (i.e., reciprocal of sampling rate)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>totalstim::Int32</code>: number of samples in simulation</li><li><code>nrep::Int32</code>: number of repetitions to simulate.</li><li><code>spont::Float64</code>: spontaneous rate, either (0.1 == low spont fiber, 4.0 == medium spont fiber, 100.0 == high spont fiber)</li><li><code>noiseType::Float64</code>: whether we use ffGn or not (1.0 == ffGn, 0.0 == not)</li><li><code>implnt::Float64</code>: whether or not to use exact implementation of power-law adaptation, either (1.0 == actual, 0.0 == approximate)</li><li><code>sampFreq::Float64</code>: sampling frequency of the power law stage in Hz. Simulations are decimated to sampFreq from 1/tdres before the power law stage and then upsampled back to the original sampling rate. The product of tdres and sampFreq, which indicates the amount to decimate by, must be an integer</li><li><code>synouttmp::Vector{Float64}</code>: array of same size as <code>ihcout</code>, used to store output from C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L597-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AuditoryNerveFiber.SingleAN!" href="#AuditoryNerveFiber.SingleAN!"><code>AuditoryNerveFiber.SingleAN!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SingleAN!(ihcout, cf, nrep, tdres, totalstim, fibertype, noiseType, implnt, meanrate, varrate, psth)</code></pre><p>Direct binding to Synapse C function in model_Synapse.c</p><p>Passes arguments directly to Synapse using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.</p><p><strong>Arguments</strong></p><ul><li><code>ihcout::Vector{Float64}</code>: output from IHC simulation (<code>IHCAN!</code>)</li><li><code>cf::Float64</code>: characteristic frequency of the fiber in Hz</li><li><code>nrep::Int32</code>: number of repetitions to simulate.</li><li><code>tdres::Float64</code>: time-domain resolution (i.e., reciprocal of sampling rate)</li><li><code>totalstim::Int32</code>: number of samples in simulation</li><li><code>fibertype::Float64</code>: fiber type, either (1.0 == low, 2.0 == med, 3.0 == high)</li><li><code>noiseType::Float64</code>: whether we use ffGn or not (1.0 == ffGn, 0.0 == not)</li><li><code>implnt::Float64</code>: whether or not to use exact implementation of power-law adaptation, either (1.0 == actual, 0.0 == approximate)</li><li><code>meanrate::Vector{Float64}</code>: array of same size as <code>ihcout</code>, used to store analytical firing rate output</li><li><code>varrate::Vector{Float64}</code>: array of same size as <code>ihcout</code>, used to store analytical firing rate variance output</li><li><code>psth::Vector{Float64}</code>: array of same size as <code>ihcout</code>, used to store empirical PSTH output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/guestdaniel/ANF.jl/blob/a87a3c36583fd573e3f9e3bfd33536d47439b171/src/AuditoryNerveFiber.jl#L655-L677">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../validation/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 28 January 2022 13:39">Friday 28 January 2022</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
