var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The best way to learn to use the package is to build from examples. Below, several example visualizations and shown using the Plots.jl package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = AuditoryNerveFiber","category":"page"},{"location":"examples/#Pure-tone-response-from-one-ANF","page":"Examples","title":"Pure-tone response from one ANF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simulating responses from a single auditory-nerve fiber is easy. sim_anrate_zbc2014 returns the instantaneous firing rate response, so we can pass a pure-tone stimulus through sim_ihc_zbc2014 to sim_an_zbc2014 and then extract the first element to get the instantaneous firing rate of the auditory nerve responding to the pure tone.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AuditoryNerveFiber\nusing AuditorySignalUtils\nusing Plots\n\n# Define variables\nfreq = 1000.0   # frequency and CF, Hz\nphase = 0.0     # starting phase, rads\ndur = 0.2       # duration, seconds\nfs = 10e4       # sampling rate, Hz\nlevel = 50.0    # level, dB SPL\nt = 0:(1/fs):prevfloat(dur)  # time axis\n\n# Synthesize a pure tone\nx = scale_dbspl(pure_tone(freq, phase, dur, fs), level);\n\n# Simulate response \ny = sim_an_zbc2014(sim_ihc_zbc2014(x, freq), freq)[1];\nplot(\n    t[1:2000], y[1:2000]; \n    ylabel=\"Firing rate (sp/s)\", \n    xlabel=\"Time (s)\", \n    label=:none\n)","category":"page"},{"location":"examples/#Iso-level-tuning-curve","page":"Examples","title":"Iso-level tuning curve","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simulating an iso-level tuning curve requires a bit more work. Here, we define simple functions that synthesize a pure tone and simulate a response to that pure tone. Then, we use map to simulate an average response at several pure-tone frequencies. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AuditoryNerveFiber\nusing AuditorySignalUtils\nusing Plots\nusing Statistics\n\n# Define variables\ncf = 1000.0     # CF, Hz\nphase = 0.0     # starting phase, rads\ndur = 0.1       # duration, seconds\nfs = 100e3      # sampling rate, Hz\nlevel = 50.0    # level, dB SPL\n\n# Define a function to synthesize a pure tone\nstim(freq) = scale_dbspl(pure_tone(freq, phase, dur, fs), level);\n\n# Define a function to simulate a single response\nresp(x) = sim_anrate_zbc2014(sim_ihc_zbc2014(x, cf), cf);\n\n# Generate a log-spaced frequency axis\nfreqs = LogRange(200.0, 20000.0, 100)\n\n# Synthesize tone and simulate response at each freq\nresults = map(freq -> mean(resp(stim(freq))), freqs)\nplot(\n    freqs, results; \n    ylabel=\"Firing rate (sp/s)\", \n    xlabel=\"Frequency (Hz)\", \n    xscale=:log10, \n    label=:none\n)","category":"page"},{"location":"examples/#Generating-spike-trains","page":"Examples","title":"Generating spike trains","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"sim_an_zbc2014 has multiple outputs.  The first is an analytic approximation of the underlying instantaneous firing rate. The second is an analytic approximation of the variance of the underlying instantaneous variance. The third is a spike train.  Here, we can see how to extract and analyze these outputs.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AuditoryNerveFiber\nusing AuditorySignalUtils\nusing Plots\n\n# Define variables\nfreq = 1000.0   # frequency and CF, Hz\nphase = 0.0     # starting phase, rads\ndur = 0.2       # duration, seconds\nfs = 10e4       # sampling rate, Hz\nlevel = 50.0    # level, dB SPL\nt = 0:(1/fs):prevfloat(dur)  # time axis\n\n# Synthesize a pure tone\nx = scale_dbspl(pure_tone(freq, phase, dur, fs), level);\n\n# Simulate response \n(rate, var, spikes) = sim_an_zbc2014(sim_ihc_zbc2014(x, freq), freq);\n\n# Plot\nl = @layout [a ; b]\np1 = plot(\n    t, rate; \n    ylabel=\"Firing rate (sp/s)\", \n    label=:none,\n)\np2 = plot(\n    t, spikes; \n    ylabel=\"Firing rate (sp/s)\", \n    label=:none,\n)\nplot(\n    p1, p2; \n    layout=l,\n    xlabel=\"Time (s)\",\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The top row shows the analytic firing rate. The bottom row shows a single example spike train. ","category":"page"},{"location":"examples/#Extending-functions-with-multiple-dispatch","page":"Examples","title":"Extending functions with multiple dispatch","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Via a set of macros defined in src/AuditoryNerveFiber.jl, most functions provided by AuditoryNerveFiber have methods to handle a range of input types. The base functions, such as sim_ihc_zbc2014 are defined in terms of a single vector input and a single scalar characteristic frequency. However, multiple dispatch means that the same function can be defined multiple times for different combinations of input types.  Each of these different definitions is called a \"method\" in Julia. You can inspect the methods of sim_ihc_zbc2014 with the methods function, and you will see that several methods are defined. Documentation of these methods is pending, but the options should be fairly intuitive","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Vector input + scalar CF => Vector output\nVector input + vector CF => Matrix output\nMatrix input + vector CF => Matrix output (one CF per row of matrix)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This makes it easy to compose inner hair cell and auditory nerve stages flexibly.  For example, if we want to generate the response to a single acoustic input at multiple CFs, we can pass a vector input and a vector of CFs.  This is shown in the neurogram demo below.","category":"page"},{"location":"examples/#Plotting-neurograms","page":"Examples","title":"Plotting neurograms","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AuditoryNerveFiber\nusing AuditorySignalUtils\nusing Plots\n\n# Define variables\nfreq = 1000.0   # freq, Hz\nphase = 0.0     # starting phase, rads\ndur = 0.2       # duration, seconds\nfs = 100e3       # sampling rate, Hz\nlevel = 50.0    # level, dB SPL\nt = 0:(1/fs):prevfloat(dur)  # time axis, s\ncfs = LogRange(200.0, 20000.0, 100)  # CFs, Hz\n\n# Synthesize a pure tone\nx = scale_dbspl(pure_tone(freq, phase, dur, fs), level);\n\n# Simulate IHC response at several CFs\nresults = sim_anrate_zbc2014(sim_ihc_zbc2014(x, cfs), cfs)\n\n# Plot\nheatmap(\n    t[1:3000], cfs, results[:, 1:3000]; \n    xlabel=\"Time (s)\", \n    ylabel=\"CF (Hz)\",\n    yscale=:log10,\n)","category":"page"},{"location":"examples/#Simulating-hearing-loss","page":"Examples","title":"Simulating hearing loss","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can extend our neurogram simulation above to simulate what happens in the case of broad loss of outer hair cells by passing a new value to the cohc parameter in sim_ihc_zbc2014. We'll do something even a bit fancier â€“- by wrapping the entire routine in a function, we can easily repeat the simulation for various levels of cohc and compare them side-by-side.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AuditoryNerveFiber\nusing AuditorySignalUtils\nusing Plots\n\nfunction viz_hearing_loss(cohc)\n    # Define variables\n    freq = 1000.0   # freq, Hz\n    phase = 0.0     # starting phase, rads\n    dur = 0.2       # duration, seconds\n    fs = 100e3       # sampling rate, Hz\n    level = 50.0    # level, dB SPL\n    t = 0:(1/fs):prevfloat(dur)  # time axis, s\n    cfs = LogRange(200.0, 20000.0, 100)  # CFs, Hz\n\n    # Synthesize a pure tone\n    x = scale_dbspl(pure_tone(freq, phase, dur, fs), level);\n\n    # Simulate IHC response at several CFs\n    results = sim_anrate_zbc2014(sim_ihc_zbc2014(x, cfs; cohc=cohc), cfs)  # here we pass cohc to sim_ihc_zbc2014\n\n    # Plot\n    heatmap(\n        t[1:3000], cfs, results[:, 1:3000]; \n        xlabel=\"Time (s)\", \n        ylabel=\"CF (Hz)\",\n        yscale=:log10,\n        clim=(0, 1000),\n        title=\"OHC loss = $((1-cohc)*100)%\",\n    )\nend\n\n# Run function and plot results\nplots = map(viz_hearing_loss, [1.0, 0.5, 0.1, 0.01])\nplot(plots...; layout=(4, 1), size=(500, 300*4))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As can be seen, with significant OHC loss the response becomes weaker over all (in terms of average firing rate) and becomes more broadly tuned.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Here, you can see the documentation for each type and method provided by AuditoryNerveFiber.jl. Higher-level functions designed for end users are documented first, while lower-level functions designed mostly for internal are documented later.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = AuditoryNerveFiber","category":"page"},{"location":"reference/#Wrappers","page":"Reference","title":"Wrappers","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Wrappers are functions that \"wrap\" around lower-level bindings and/or implementations and provide more convenience than the bindings themselves. For example, when calling wrappers a user should never have to worry about handling pointers, pre-allocating arrays, etc. These are the functions that most users will want to use in their own code. Presently, the wrappers provide access to the Zilany, Bruce, and Carney (2014) auditory-nerve model and all share the same basic signature:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"func(input, cf; kwargs)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where the input is a 1D array, cf is a characteristic frequency in Hz, and kwargs are various other parameters that have default values (i.e., you can set them if you want to, but if you don't a default value will be used). Below, you can see each of the wrappers documented below, but you can also head over to Examples to see examples of how these functions can be used.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"sim_ihc_zbc2014\nsim_synapse_zbc2014\nsim_anrate_zbc2014\nsim_an_zbc2014\nsim_an_hcc2001","category":"page"},{"location":"reference/#AuditoryNerveFiber.sim_ihc_zbc2014","page":"Reference","title":"AuditoryNerveFiber.sim_ihc_zbc2014","text":"sim_ihc_zbc2014(input, cf; fs=10e4, cohc=1.0, cihc=1.0, species=\"human\", n_rep=1)\n\nSimulates inner hair cell potential for given acoustic input.\n\nArguments\n\ninput::Vector{Float64}: sound pressure waveform in pascals\ncf::Float64: characteristic frequency of the IHC in Hz\nfs::Float64: sampling rate in Hz\ncohc::Float64: outer hair cell survival (from 0 to 1)\ncihc::Float64: inner hair cell survival (from 0 to 1)\nspecies::String: species, either \"cat\", \"human\" (Shera tuning), or \"human_glasberg\" (Glasberg tuning)\n\nReturns\n\noutput::Vector{Float64}: inner hair cell potential output\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.sim_synapse_zbc2014","page":"Reference","title":"AuditoryNerveFiber.sim_synapse_zbc2014","text":"sim_synapse_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, fiber_type=\"high\", power_law=\"approximate\", fractional=false, n_rep=1)\n\nSimulates synapse output for a given inner hair cell input\n\nArguments\n\ninput::Vector{Float64}: input hair cell potential (from simihczbc2014)\ncf::Float64: characteristic frequency of the fiber in Hz\nfs::Float64: sampling rate of the input in Hz\nfs_synapse::Float64: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.\nfiber_type::String: fiber type, one of (\"low\", \"medium\", \"high\") spontaneous rate\npower_law::String: whether we use true or approximate power law adaptation, one of (\"actual\", \"approximate\")\nfractional::Bool: whether we use ffGn or not, one of (true, false)\nn_rep::Int64: number of repetititons to run \n\nReturns\n\noutput::Vector{Float64}: synapse output (unknown units?)\n\nWarnings\n\nnrep is not tested and it's not clear that it's producing the right output behavior. If you intend to use the nrep argument for anything other than n_rep > 1, examine your outputs carefully and report any bugs to GitHub\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.sim_anrate_zbc2014","page":"Reference","title":"AuditoryNerveFiber.sim_anrate_zbc2014","text":"sim_anrate_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, power_law=\"approximate\", fractional=false)\n\nSimulates auditory nerve output (instantaneous firing rate) for a given inner hair cell input\n\nArguments\n\ninput::Vector{Float64}: input hair cell potential (from simihczbc2014)\ncf::Float64: characteristic frequency of the fiber in Hz\nfs::Float64: sampling rate of the input in Hz\nfs_synapse::Float64: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.\nfiber_type::String: fiber type, one of (\"low\", \"medium\", \"high\") spontaneous rate\npower_law::String: whether we use true or approximate power law adaptation, one of (\"actual\", \"approximate\")\nfractional::Bool: whether we use ffGn or not, one of (true, talse)\n\nReturns\n\nmeanrate::Vector{Float64}: analytical estimate of instantaneous firing rate\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.sim_an_zbc2014","page":"Reference","title":"AuditoryNerveFiber.sim_an_zbc2014","text":"sim_an_zbc2014(input, cf; fs=10e4, fs_synapse=10e3, power_law=\"approximate\", fractional=false, n_rep=1)\n\nSimulates auditory nerve output (spikes and firing rate) for a given inner hair cell input\n\nArguments\n\ninput::Vector{Float64}: input hair cell potential (from simihczbc2014)\ncf::Float64: characteristic frequency of the fiber in Hz\nfs::Float64: sampling rate of the input in Hz\nfs_synapse::Float64: sampling rate of the interior synapse simulation. The ratio between fs and fs_synapse must be an integer.\nfiber_type::String: fiber type, one of (\"low\", \"medium\", \"high\") spontaneous rate\npower_law::String: whether we use true or approximate power law adaptation, one of (\"actual\", \"approximate\")\nfractional::Bool: whether we use ffGn or not, one of (true, talse)\nn_rep::Int64: number of repetititons to run\n\nReturns\n\nmeanrate::Vector{Float64}: analytical estimate of instantaneous firing rate\nvarrrate::Vector{Float64}: analytical estimate of instantaneous firing rate variance\npsth::Vector{Float64}: peri-stimulus time histogram \n\nWarnings\n\nnrep is not tested and it's not clear that it's producing the right output behavior. If you intend to use the nrep argument for anything other than n_rep > 1, examine your outputs carefully and report any bugs to GitHub\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.sim_an_hcc2001","page":"Reference","title":"AuditoryNerveFiber.sim_an_hcc2001","text":"sim_an_hcc2001(input, cf; fs=100e3)\n\nSimulates auditory nerve output (instantaneous firing rate) for a given acoustic input. \n\nAuditory-nerve model from the Heinz, Colburn, and Carney (2001) paper cited below. Includes a gammatone filterbank (basilar membrane stage), a saturating nonlinearity (IHC stage), and adaptation dynamics (AN stage).\n\nArguments\n\ninput::Vector{Float64}: acoustic stimulus (Pa)\ncf::Float64: characteristic frequency of the fiber (Hz)\nfs::Float64: sampling rate of the input (Hz)\n\nReturns\n\n::Vector{Float64}: Instantaneous firing rate (spikes/s)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Bindings","page":"Reference","title":"Bindings","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Bindings are functions that directly interface with external implementations of models in other languages.  All bindings here work generally the same way:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Inputs are passed directly to external functions with minimal or no input checking or preprocessing\nNo defaults are provided\nNames and types of variables match those of the original-language source code","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Generally, it is expected that end-users will never need to call these functions.  Instead, they should use a wrapper or another higher-level function to access the same functionality in a a more \"user-friendly\" way.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"IHCAN!\nSynapse!\nSingleAN!","category":"page"},{"location":"reference/#AuditoryNerveFiber.IHCAN!","page":"Reference","title":"AuditoryNerveFiber.IHCAN!","text":"IHCAN!(px, cf, nrep, tdres, totalstim, cohc, cihc, species, ihcout)\n\nDirect binding to IHCAN C function in model_IHC.c\n\nPasses arguments directly to IHCAN using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.\n\nArguments\n\npx::Vector{Float64}: sound pressure waveform in pascals\ncf::Float64: characteristic frequency of the fiber in Hz\nnrep::Int32: number of repetitions to simulate. Note that for the IHC simulation, one \"true\" simulation is conducted and then that simulation is copied and tiled (because there is no randomness in the IHC simulation) to simulate multiple times.\ntdres::Float64: time-domain resolution (i.e., reciprocal of sampling rate)\ntotalstim::Int32: number of samples in simulation\ncohc::Float64: outer hair cell survival (from 0 to 1)\ncihc::Float64: inner hair cell survival (from 0 to 1)\nspecies::Int32: species, either (1 = cat, 2 = humans with Shera tuning, 3 = humans with Glasberg tuning)\nihcout::Vector{Float64}: array of same size as px, used to store output from C\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.Synapse!","page":"Reference","title":"AuditoryNerveFiber.Synapse!","text":"Synapse!(ihcout, tdres, cf, totalstim, nrep, spont, noiseType, implnt, sampFreq, synouttmp)\n\nDirect binding to Synapse C function in model_Synapse.c\n\nPasses arguments directly to Synapse using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.\n\nArguments\n\nihcout::Vector{Float64}: output from IHC simulation (IHCAN!)\ntdres::Float64: time-domain resolution (i.e., reciprocal of sampling rate)\ncf::Float64: characteristic frequency of the fiber in Hz\ntotalstim::Int32: number of samples in simulation\nnrep::Int32: number of repetitions to simulate.\nspont::Float64: spontaneous rate, either (0.1 == low spont fiber, 4.0 == medium spont fiber, 100.0 == high spont fiber)\nnoiseType::Float64: whether we use ffGn or not (1.0 == ffGn, 0.0 == not)\nimplnt::Float64: whether or not to use exact implementation of power-law adaptation, either (1.0 == actual, 0.0 == approximate)\nsampFreq::Float64: sampling frequency of the power law stage in Hz. Simulations are decimated to sampFreq from 1/tdres before the power law stage and then upsampled back to the original sampling rate. The product of tdres and sampFreq, which indicates the amount to decimate by, must be an integer\nsynouttmp::Vector{Float64}: array of same size as ihcout, used to store output from C\n\n\n\n\n\n","category":"function"},{"location":"reference/#AuditoryNerveFiber.SingleAN!","page":"Reference","title":"AuditoryNerveFiber.SingleAN!","text":"SingleAN!(ihcout, cf, nrep, tdres, totalstim, fibertype, noiseType, implnt, meanrate, varrate, psth)\n\nDirect binding to Synapse C function in model_Synapse.c\n\nPasses arguments directly to Synapse using ccall. Arrays are converted to pointers,  functions are converted to pointers, and all other types are converted directly to  corresponding types in C. Note that while there are type checks enforced automatically by  Julia, there are no sanity checks on any arguments.\n\nArguments\n\nihcout::Vector{Float64}: output from IHC simulation (IHCAN!)\ncf::Float64: characteristic frequency of the fiber in Hz\nnrep::Int32: number of repetitions to simulate.\ntdres::Float64: time-domain resolution (i.e., reciprocal of sampling rate)\ntotalstim::Int32: number of samples in simulation\nfibertype::Float64: fiber type, either (1.0 == low, 2.0 == med, 3.0 == high)\nnoiseType::Float64: whether we use ffGn or not (1.0 == ffGn, 0.0 == not)\nimplnt::Float64: whether or not to use exact implementation of power-law adaptation, either (1.0 == actual, 0.0 == approximate)\nmeanrate::Vector{Float64}: array of same size as ihcout, used to store analytical firing rate output\nvarrate::Vector{Float64}: array of same size as ihcout, used to store analytical firing rate variance output\npsth::Vector{Float64}: array of same size as ihcout, used to store empirical PSTH output\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AuditoryNerveFiber.jl is a Julia package that provides access to implementations of auditory-nerve models.  This is the documentation for AuditoryNerveFiber.jl, and here you can learn about how to use the package and access information about details of the underlying implementations. If you have any issues, please raise them at the Github page or email me at guest121@umn.edu. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AuditoryNerveFiber","category":"page"}]
}
